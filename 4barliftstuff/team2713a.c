#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    Potentiometer,  sensorPotentiometer)
#pragma config(Sensor, I2C_1,  frontIEM,       sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  rightIEM,       sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  backIEM,        sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  leftIEM,        sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           thing1top,     tmotorVex393, openLoop)
#pragma config(Motor,  port2,           backMotor,     tmotorVex269, openLoop, encoder, encoderPort, I2C_3, 1000)
#pragma config(Motor,  port4,           armMotor,      tmotorVex393, openLoop)
#pragma config(Motor,  port5,           armMotor2,     tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port6,           wristmotor,    tmotorVex393, openLoop)
#pragma config(Motor,  port7,           frontMotor,    tmotorVex269, openLoop, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port8,           rightMotor,    tmotorVex269, openLoop, encoder, encoderPort, I2C_2, 1000)
#pragma config(Motor,  port10,          leftMotor,     tmotorVex269, openLoop, encoder, encoderPort, I2C_4, 1000)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

int DOWN_TARGET = 3936;
int UP_TARGET = 3255;
float TARGET = DOWN_TARGET;//global variable for arm position
float TARGET_ADJUST = 0.001;
void pidArmControl()
{
	//float Kp = 0.25;// Floats were crashing the progam for some reason. -Mike
	int Kp = 4;
	int position = SensorValue(Potentiometer);
	int e = floor(TARGET) - position;
	int motorOutput = e >> 2;//Doing a bit shift to divide by 4
	// I was trying to divide by Kp, but it was raising an exception (opcode 75).
	// I don't know why robotC doesn't like fractions. -Mike
	// using the floor funtion seems to work. -Mike
	if (motorOutput > 127)
	{
		motorOutput = 127;
	}
	else if (motorOutput< -127)
	{
		motorOutput = -127;
	}
	motor[armMotor] = motorOutput;
	motor[armMotor2] = motorOutput;
}





void pre_auton()
{
	bStopTasksBetweenModes = true;

	nMotorEncoder[rightMotor] = 0;
	nMotorEncoder[leftMotor] = 0;
	nMotorEncoder[frontMotor] = 0;
	nMotorEncoder[backMotor] = 0;

}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
	wait1Msec(1000);
	while((SensorValue[I2C_1] <= 69)&&(SensorValue[I2C_3]<= 69))
	{
		motor[frontMotor] = 63;
		motor[backMotor]  = 63;
	}
	while((SensorValue[I2C_1] >= 69)&&(SensorValue[I2C_3] >= 69))
	{
		motor[frontMotor] = 0;
		motor[backMotor] = 0;
	}
	while(SensorValue[Potentiometer] <= 52)
	{
		motor[armMotor] = 63;
		motor[armMotor2] = 63;
	}
	while(SensorValue[Potentiometer] >= 0)
	{
		motor[armMotor] = 0;
		motor[armMotor2] = 0;
	}
	wait1Msec(1000);
	motor[thing1top] = -50;

}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//

/////////////////////////////////////////////////////////////////////////////////////////
task usercontrol()
{
	// User control code here, inside the loop

	while (true)
	{
		pidArmControl();

		if(vexRT[Btn6U] == 1)
		{
			motor[armMotor] = 100;
			motor[armMotor2] = 100;
		}
		else if(vexRT[Btn6D] == 1)
		{
			motor[armMotor] = -100;
			motor[armMotor2] = -100;
		}
		else if(vexRT[Btn5U]==1)
		{
			motor[thing1top] = 100;

		}
		else if (vexRT[Btn7U] == 1)
		{
			TARGET = UP_TARGET;

		}
		else if (vexRT[Btn7D] == 1)
		{
			TARGET=DOWN_TARGET;
		}
		else if (vexRT[Btn7L] == 1)

		{
			//Note: This is not working as expected because pressing the button results in this being executed hundreds of times.
			TARGET = TARGET-TARGET_ADJUST;
		}
		else if(vexRT[Btn7R] == 1)
		{
			TARGET = TARGET + TARGET_ADJUST;
		}
		else
		{
			motor[armMotor2] = 0;
			motor[armMotor] = 0;
			motor[thing1top] = 0;
		}
		if( vexRT[Ch4] == 0)
		{
			int iCh1 = vexRT[Ch1];
			int iCh2 = vexRT[Ch2];
			if(vexRT[Ch1] > -15 && vexRT[Ch1] < 15)
			{

				iCh1 = 0;
			}

			bMotorReflected[port8] = false;
			bMotorReflected[port10] = true;
			bMotorReflected[port2] = false;
			bMotorReflected[port7] = true;
			motor[port8] = iCh1;							// Remove these as well and replace with your appropriate code
			motor[port10] = iCh1;              // Remove these as well and replace with your appropriate code

			motor[port2] = iCh2;
			motor[port7] = iCh2;
		}
		else
		{
			bMotorReflected[port8] = true;
			bMotorReflected[port10] = true;
			bMotorReflected[port2] = true;
			bMotorReflected[port7] = true;
			motor[port8] = vexRT[Ch4];							// Remove these as well and replace with your appropriate code
			motor[port10] = vexRT[Ch4];              // Remove these as well and replace with your appropriate code
			motor[port2] = vexRT[Ch4];
			motor[port7] = vexRT[Ch4];

		}
	}
}
void pidArmControl()
{

	int Kp = 10;// needs to be changed once achieve real value

	int position = SensorValue(Potentiometer);
	float error = TARGET - position;
	float output =abs( Kp * error);

	motor[armMotor] = output;
	motor[armMotor2] = output;

}
